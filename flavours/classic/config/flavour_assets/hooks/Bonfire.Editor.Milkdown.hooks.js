/*
This file was generated by the Surface compiler.
*/

import {
	defaultValueCtx,
	editorViewOptionsCtx,
	Editor,
	editorViewCtx,
	rootCtx,
} from "@milkdown/kit/core";
import { $prose, replaceAll, insert } from "@milkdown/utils";
import {
	commonmark, headingAttr, paragraphAttr 
} from "@milkdown/kit/preset/commonmark";
import { configureLinkTooltip, linkTooltipPlugin } from '@milkdown/kit/component/link-tooltip';

// import { history } from "@milkdown/kit/plugin/history";
import { gfm } from "@milkdown/kit/preset/gfm";
import { emoji } from "@milkdown/plugin-emoji";
import { listener, listenerCtx } from "@milkdown/kit/plugin/listener";
import { SlashProvider, slashFactory } from "@milkdown/kit/plugin/slash";
// import { gemoji } from "gemoji";
import { clipboard } from "@milkdown/kit/plugin/clipboard";
// import { createPopup } from "@picmo/popup-picker";
import { Plugin, PluginKey } from "@milkdown/kit/prose/state";
import { Decoration, DecorationSet } from "@milkdown/kit/prose/view";
import 'emoji-picker-element';
import { Picker } from 'emoji-picker-element';

const PlaceholderPlugin = new Plugin({
	key: new PluginKey("milkdown-placeholder"),
	props: {
		decorations: (state) => {
			const element = document.createElement("span");

			element.classList.add("milkdown-placeholder");
			element.style.position = "absolute";
			element.style.opacity = "0.5";
			element.innerText = "Write something...";

			const placeholderDecoration = Decoration.widget(0, element, {
				key: "milkdown-placeholder",
				side: 0,
			});
			if (state.doc.textContent.trim().length === 0) {
				return DecorationSet.create(state.doc, [placeholderDecoration]);
			}
		},
	},
});
const placeholder = $prose(() => PlaceholderPlugin);

const MIN_PREFIX_LENGTH = 2;
const VALID_CHARS = "[\\w\\+_\\-:]";
const MENTION_PREFIX = "(?:@)";
// const EMOJI_PREFIX = "(?::)";
const MENTION_REGEX = new RegExp(
	`(?:\\s|^)(${MENTION_PREFIX}${VALID_CHARS}{${MIN_PREFIX_LENGTH},})$`,
);
// const EMOJI_REGEX = new RegExp(
// 	`(?:\\s|^)(${EMOJI_PREFIX}${VALID_CHARS}{${MIN_PREFIX_LENGTH},})$`,
// );

import "@milkdown/theme-nord/style.css";

const markdown = ``;

function mentionsPluginView(view) {
	const content = document.createElement("ul");
	content.tabIndex = 1;

	content.className =
		"milkdown-menu absolute m-0 p-0 menu left-menu bg-base-200 border border-base-content/10 shadow-xl border-lg";
	let list = "";

	const provider = new SlashProvider({
		content,
		shouldShow: (view, prevState) => {
			// get the current content of the editor
			const { state } = view;
			const { doc } = state;
			const currentText = doc.textContent;

			if (currentText === "") {
				return false;
			}

			const mentions = currentText.match(MENTION_REGEX);
			// Display the menu if the last character is `@` followed by 2 chars.
			if (mentions) {
				// get the characters that follows the `@` in currentText
				const text = mentions[1].split("@").pop();

				return getFeedItems(text, "@").then((res) => {
					list = "";
					if (res.length > 0) {
						// Add max 4 items to the menu
						let maxItems = 4;
						for (let i = 0; i < res.length && i < maxItems; i++) {
							list += mentionItemRenderer(res[i], text);
						}
						content.innerHTML = list;
						return true;
					} else {
						content.innerHTML = "";
						return false;
					}
				});
			}

			return false;
		},
		trigger: "@",
	});

	return {
		update: (updatedView, prevState) => {
			provider.update(updatedView, prevState);
		},
		destroy: () => {
			provider.destroy();
			content.remove();
		},
	};
}

// function emojisPluginView() {
// 	const content = document.createElement("ul");
// 	content.tabIndex = 1;

// 	content.className =
// 		"milkdown-menu absolute m-0 p-0 menu w-72 bg-base-100 border border-base-content/10 shadow-lg";
// 	let list = "";

// 	const provider = new SlashProvider({
// 		content,
// 		shouldShow: (view, prevState) => {
// 			// get the current content of the editor
// 			const { state } = view;
// 			const { doc } = state;
// 			const currentText = doc.textContent;

// 			if (currentText === "") {
// 				return false;
// 			}

// 			const emojis = currentText.match(EMOJI_REGEX);
// 			// Display the menu if the last character is `@` followed by 2 chars.
// 			if (emojis) {
// 				// get the characters that follows the `@` in currentText
// 				const text = emojis[1].split(":").pop();
// 				const index = gemoji.findIndex((emoji) => {
// 					return emoji.names.some((name) => name.includes(text));
// 				});
// 				list = "";
// 				if (index > 0) {
// 					// Add max 4 items to the menu
// 					gemoji
// 						.filter((emoji) => {
// 							return emoji.names.some((name) => name.includes(text));
// 						})
// 						.slice(0, 6)
// 						.map((emoji) => {
// 							list += emojiItemRenderer(emoji, text);
// 						});

// 					content.innerHTML = list;

// 					// Add click event listener to close modal when emoji is clicked
// 					content.querySelectorAll('.emoji_btn').forEach(btn => {
// 						btn.addEventListener('click', () => {
// 							const picker = document.querySelector('emoji-picker');
// 							if (picker) {
// 								picker.style.display = 'none';
// 							}
// 						});
// 					});

// 					return true;
// 				} else {
// 					content.innerHTML = "";
// 					return false;
// 				}
// 			}
// 			return false;
// 		},
// 		trigger: ":",
// 	});

// 	return {
// 		update: (updatedView, prevState) => {
// 			provider.update(updatedView, prevState);
// 		},
// 		destroy: () => {
// 			provider.destroy();
// 			content.remove();
// 		},
// 	};
// }

// function slashPluginView(view) {
//   const content = document.createElement('ul');
//   content.tabIndex = 1;

//   content.className = 'm-0 p-0 menu w-72 bg-base-100 shadow-lg ring-2';
//   let list = slashItemRenderer()
//   content.innerHTML = list

//   const provider = new SlashProvider({
//     content,
//     trigger: '/',
//   });

//   return {
//     update: (updatedView, prevState) => {
//       provider.update(updatedView, prevState);
//     },
//     destroy: () => {
//       provider.destroy();
//       content.remove();
//     }
//   }
// }

function getFeedItems(queryText, prefix) {
  if (!queryText?.length) return Promise.resolve([]);

  return fetch("/api/tag/autocomplete/ck5/" + prefix + "/" + queryText)
    .then(response => {
      console.log(response); // Add this line to log the response to the console for debugging purposes in the browser dev tools pan
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      console.log(data); // Add this line to log the data to the console for debugging purposes in the browser dev tools pan
      console.log("qui")
      return data.map(item => ({
        id: item.id,
        value: item.name,
        icon: item.icon,
      }));
    })
    .catch(error => {
      console.error("Tag search error:", error);
      return [];
    });
}

const mentionItemRenderer = (item, text) => {
	return `
    <li class="rounded-none">
      <button type="button" data-mention="${item.id}" data-text="${text}" class="mention_btn rounded-none w-full flex items-center">
        <div class="flex items-center gap-3 w-full pointer-events-none">
          <div class="flex-shrink-0">
            <img class="h-6 w-6 rounded-full" src="${item.icon}" alt="">
          </div>
          <div class="gap-0 items-start flex flex-col" data-id="${item.id}" data-input="${text}">
            <div class="text-sm truncate max-w-[240px] text-base-content font-semibold">${item.value}</div>
            <div class="text-xs truncate max-w-[240px] text-base-content/70 font-regular">${item.id}</div>
          </div>
        </div>
      </button>
    </li>`;
};

// const emojiItemRenderer = (item, text) => {
// 	return `
//     <li class="rounded-none">
//       <button type="button" data-text="${text}" data-emoji=${item.emoji} class="emoji_btn gap-3 rounded-none w-full flex items-center">
//         <div class="pointer-events-none flex items-baseline w-full gap-2">
//           <span>${item.emoji}</span>  <span class="truncate max-w-[220px]">:${item.names[0]}:</span>
//         </div>
//       </button>
//     </li>`;
// };

// const slashItemRenderer = () => {
//   return `
//     <li class="rounded-none">
//       <button type="button" class="heading_btn rounded-none flex items-center gap-2">
//         <span class="pointer-events-none material-symbols-outlined text-nord-10 dark:text-nord-9">
//           <svg class="w-5 h-5 shrink-0 flex-1 text-info" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M6 17q-.425 0-.713-.288T5 16V8q0-.425.288-.713T6 7q.425 0 .713.288T7 8v3h4V8q0-.425.288-.713T12 7q.425 0 .713.288T13 8v8q0 .425-.288.713T12 17q-.425 0-.713-.288T11 16v-3H7v3q0 .425-.288.713T6 17Zm12 0q-.425 0-.713-.288T17 16V9h-1q-.425 0-.713-.288T15 8q0-.425.288-.713T16 7h2q.425 0 .713.288T19 8v8q0 .425-.288.713T18 17Z"/></svg>
//         </span>
//         Heading
//       </button>
//     </li>
//     <li class="rounded-none">
//       <button type="button" class="bold_btn rounded-none flex items-center gap-2">
//         <span class="material-symbols-outlined text-nord-10 dark:text-nord-9">
//           <svg class="w-5 h-5 shrink-0 flex-1 text-info" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M6 17q-.425 0-.713-.288T5 16V8q0-.425.288-.713T6 7q.425 0 .713.288T7 8v3h4V8q0-.425.288-.713T12 7q.425 0 .713.288T13 8v8q0 .425-.288.713T12 17q-.425 0-.713-.288T11 16v-3H7v3q0 .425-.288.713T6 17Zm12 0q-.425 0-.713-.288T17 16V9h-1q-.425 0-.713-.288T15 8q0-.425.288-.713T16 7h2q.425 0 .713.288T19 8v8q0 .425-.288.713T18 17Z"/></svg>
//         </span>
//         Bold
//       </button>
//     </li>
//     <li class="rounded-none">
//       <button type="button"  class="italic_btn rounded-none flex items-center gap-2">
//         <span class="material-symbols-outlined text-nord-10 dark:text-nord-9">
//           <svg class="w-5 h-5 shrink-0 flex-1 text-info" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M6 17q-.425 0-.713-.288T5 16V8q0-.425.288-.713T6 7q.425 0 .713.288T7 8v3h4V8q0-.425.288-.713T12 7q.425 0 .713.288T13 8v8q0 .425-.288.713T12 17q-.425 0-.713-.288T11 16v-3H7v3q0 .425-.288.713T6 17Zm12 0q-.425 0-.713-.288T17 16V9h-1q-.425 0-.713-.288T15 8q0-.425.288-.713T16 7h2q.425 0 .713.288T19 8v8q0 .425-.288.713T18 17Z"/></svg>
//         </span>
//         Italic
//       </button>
//     </li>
//     <li class="rounded-none">
//       <button  type="button"  class="link_btn rounded-none flex items-center gap-2">
//         <span class="material-symbols-outlined text-nord-10 dark:text-nord-9">
//           <svg class="w-5 h-5 shrink-0 flex-1 text-info" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M6 17q-.425 0-.713-.288T5 16V8q0-.425.288-.713T6 7q.425 0 .713.288T7 8v3h4V8q0-.425.288-.713T12 7q.425 0 .713.288T13 8v8q0 .425-.288.713T12 17q-.425 0-.713-.288T11 16v-3H7v3q0 .425-.288.713T6 17Zm12 0q-.425 0-.713-.288T17 16V9h-1q-.425 0-.713-.288T15 8q0-.425.288-.713T16 7h2q.425 0 .713.288T19 8v8q0 .425-.288.713T18 17Z"/></svg>
//         </span>
//         Link
//       </button>
//     </li>

//     <li class="rounded-none">
//       <button type="button"  class="divider_btn rounded-none flex items-center gap-2">
//         <span class="material-symbols-outlined text-nord-10 dark:text-nord-9">
//           <svg class="w-5 h-5 shrink-0 flex-1 text-info"  xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path fill="currentColor" fill-rule="evenodd" d="M2 7.5a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1h-10a.5.5 0 0 1-.5-.5Z" clip-rule="evenodd"/></svg>
//         </span>
//         Divider
//       </button>
//     </li>
//     `

// }

const mentionSlash = slashFactory("mentions-slash");
// const emojisSlash = slashFactory("emojis-slash");
// const slash = slashFactory('slash');
let currentPicker = null;

const initEmojiPicker = (editor) => {
  const pickerContainer = document.querySelector('.emoji-picker-in-composer');
  if (!pickerContainer) return;

  // Clean up any existing picker
  if (currentPicker) {
    currentPicker.remove();
    currentPicker = null;
  }

  // Get custom emojis from data attribute
  let customEmoji = [];
  try {
    const emojisData = pickerContainer.getAttribute('data-emojis');
    if (emojisData) {
      customEmoji = JSON.parse(emojisData);
    }
  } catch (e) {
    console.error('Failed to parse custom emojis:', e);
  }
  currentPicker = new Picker({
    locale: 'en',
    customEmoji,
    referenceElement: pickerContainer,
    triggerElement: pickerContainer,
    emojiSize: "1.75rem",
  });

  pickerContainer.appendChild(currentPicker);

  // Handle emoji selection
  currentPicker.addEventListener('emoji-click', event => {
    const { unicode, emoji } = event.detail;
    
    editor.action((ctx) => {
      const view = ctx.get(editorViewCtx);
      
      // Use shortcode only when unicode is missing
      const text = !unicode && emoji?.shortcodes?.[0] 
        ? emoji.shortcodes[0]
        : unicode || '';
      
      if (!text) {
        console.warn('No valid emoji text to insert');
        return;
      }

      try {
        view.dispatch(view.state.tr.insertText(text + " "));
        view.focus();
      } catch (error) {
        console.error('Failed to insert emoji:', error);
      }
    });
  });
};

const createEditor = async (_this, hidden_input, composer$) => {
  if (!hidden_input || !composer$) {
    throw new Error("Required elements not found");
  }

	const editor = await Editor.make()
		.config((ctx) => {
			ctx.set(rootCtx, "#editor");
			ctx.set(defaultValueCtx, markdown);
			ctx.set(headingAttr.key, (node) => {
			const level = node.attrs.level;
				if (level === 1) return { class: 'text-xl', "data-el-type": 'h3', id: null };
				if (level === 2) return { class: 'text-xl', "data-el-type": 'h3', id: null };
				if (level === 3) return { class: 'text-xl', "data-el-type": 'h3', id: null };
				if (level === 4) return { class: 'text-xl', "data-el-type": 'h3', id: null };
				if (level === 5) return { class: 'text-xl', "data-el-type": 'h4', id: null };
				if (level === 6) return { class: 'text-xl', "data-el-type": 'h4', id: null };
			});
			ctx.set(paragraphAttr.key, () => ({ class: 'text-base' }));
			ctx.update(editorViewOptionsCtx, (prev) => ({
				...prev,
				attributes: { class: 'milkdown-editor mx-auto outline-none', spellcheck: 'false' },
			  }));
			// ctx.set(editorViewOptionsCtx, { 
			// 	editable: () => true,
			// 	handlePaste: (view, event) => {
			// 		event.preventDefault();
			// 		const text = event.clipboardData.getData('text/plain');
			// 		console.log(text);
			// 		view.dispatch(view.state.tr.insertText(text));
			// 		return true;
			// 	}
			// });
			
			ctx.set(paragraphAttr.key, () => ({ class: 'text-base' }));
			ctx.set(mentionSlash.key, {
				view: mentionsPluginView,
			});
			// ctx.set(emojisSlash.key, {
			// 	view: emojisPluginView,
			// });
			ctx.get(listenerCtx).markdownUpdated((ctx, markdown, prevMarkdown) => {
				const transformedMarkdown = markdown
					.replace(/!\[(.*?)\]\(.*?\)/g, "$1")
					// Remove backslash before # at the start of a line or after a space
					.replace(/(^|\s)\\#/g, "$1#")
					// Remove backslash before underscore in hashtags
					.replace(/(#[^_\s]+)\\(_[^_\s]+)/g, "$1$2");

				hidden_input.value = transformedMarkdown;

				console.log("transformedMarkdown");
				console.log(transformedMarkdown);
				const inputEvent = new Event("input", {
					bubbles: true,
				});

				hidden_input.dispatchEvent(inputEvent);
			});
			ctx.update(editorViewOptionsCtx, (prev) => ({
				...prev,
				attributes: {
					placeholder: "Type your text here...",
					class:
						"editor prose prose-sm h-full p-2 focus:outline-none composer w-full max-w-full prose-p:first-of-type:mt-0 prose-a:text-primary prose-a:no-underline hover:prose-a:underline prose-a:hover:underline prose-p:mb-0 prose-p:mt-0 prose-h1:mb-0 prose-h2:my-0 prose-h3:mb-0 prose-h4:mb-0",
					spellcheck: "false",
				},
			}));
		})
		//.config(nord)
		.config(configureLinkTooltip)
		.use(clipboard)
		.use(commonmark)
		.use(gfm)
		.use(linkTooltipPlugin)
		// .use(remarkInlineLinkPlugin)
		.use(emoji)
		.use(listener)
		.use(mentionSlash)
		// .use(emojisSlash)
		.use(placeholder)
		// .use(slash)
		.create();

	initEmojiPicker(editor);
	_this.handleEvent("smart_input:reset", ({ text }) => {
		editor.action(replaceAll(""));
	});

	_this.handleEvent("mention_suggestions", ({ text }) => {
		// replace the current text with the text from the event
		console.log("test")
		editor.action(replaceAll(""));
		if (text != null) {
			editor.action((ctx) => {
				const view = ctx.get(editorViewCtx);
				view.dispatch(view.state.tr.insertText(text + " "));
				view.focus();
			});
		}
	});

	// heading_btn.addEventListener('click', (e) => {
	//   e.preventDefault();
	//   editor.action((ctx) => {
	//     const commandManager = ctx.get(commandsCtx);
	//     const view = ctx.get(editorViewCtx);
	//     commandManager.call(wrapInHeadingCommand.key, 3);
	//     view.focus()
	//   });
	// })

	// bold_btn.addEventListener("click", (e) => {
	// 	e.preventDefault();
	// 	editor.action((ctx) => {
	// 		const commandManager = ctx.get(commandsCtx);
	// 		const view = ctx.get(editorViewCtx);
	// 		const state = view.state;
	// 		const { from, to } = state.selection;
	// 		const isActive = state.schema.marks.strong.isInSet(
	// 			state.doc.rangeHasMark(from, to, state.schema.marks.strong),
	// 		);

	// 		commandManager.call(toggleStrongCommand.key);
	// 		view.focus();

	// 		// Update button class based on the current state
	// 		// if (isActive) {
	// 		//   bold_btn.classList.remove('btn-active');
	// 		// } else {
	// 		//   bold_btn.classList.add('btn-active');
	// 		// }
	// 	});
	// });

	// italic_btn.addEventListener("click", (e) => {
	// 	e.preventDefault();
	// 	editor.action((ctx) => {
	// 		const commandManager = ctx.get(commandsCtx);
	// 		const view = ctx.get(editorViewCtx);
	// 		commandManager.call(toggleEmphasisCommand.key);
	// 		view.focus();
	// 	});
	// });

	// quote_btn.addEventListener('click', (e) => {
	//   e.preventDefault();
	//   editor.action((ctx) => {
	//     const commandManager = ctx.get(commandsCtx);
	//     const view = ctx.get(editorViewCtx);
	//     commandManager.call(wrapInBlockquoteCommand.key);
	//     view.focus()
	//   });
	// })

	// strike_btn.addEventListener('click', (e) => {
	//   e.preventDefault();
	//   editor.action((ctx) => {
	//     const commandManager = ctx.get(commandsCtx);
	//     const view = ctx.get(editorViewCtx);
	//     commandManager.call(toggleStrikethroughCommand.key);
	//     view.focus()
	//   });
	// })

	// table_btn.addEventListener('click', (e) => {
	//   e.preventDefault();
	//   editor.action((ctx) => {
	//     const commandManager = ctx.get(commandsCtx);
	//     const view = ctx.get(editorViewCtx);
	//     commandManager.call(insertTableCommand.key);
	//     view.focus()
	//   });
	// })

	composer$.addEventListener("click", (e) => {
		if (e.target.matches(".emoji_btn")) {
			e.preventDefault();
			const emoji = e.target.dataset.emoji;
			const text = e.target.dataset.text;
			editor.action((ctx) => {
				const view = ctx.get(editorViewCtx);
				const { state } = view;
				const { selection } = state;
				view.dispatch(
					view.state.tr
						.delete(selection.from - text.length - 1, selection.from)
						.insertText(emoji + " "),
				);
				view.focus();
			});
		}

		if (e.target.matches(".mention_btn")) {
			e.preventDefault();
			const mention = e.target.dataset.mention;
			const text = e.target.dataset.text;
			editor.action((ctx) => {
				const view = ctx.get(editorViewCtx);
				const { state } = view;
				const { selection } = state;

				// Calculate the start position for deletion
				const startPos = selection.from - text.length - 1;

				view.dispatch(
					view.state.tr
						.delete(startPos, selection.from)
						.insertText(`${mention} ` + `\u200B `), // add a space character after the mention variable
				);
				view.focus();
			});
		}
	});

	return {
    editor,
    cleanup: () => {
      if (currentPicker) {
        currentPicker.remove();
        currentPicker = null;
      }
      editor?.destroy();
    }
};
}

export default {
  mounted() {
    const hidden_input = document.getElementById("editor_hidden_input");
    const composer$ = this.el.querySelector("#editor");

    this.focusComposerHandler = (event) => {
      const contentEditableDiv = this.el.querySelector("[contenteditable]");
      if (!contentEditableDiv) return;
      
      contentEditableDiv.focus();
      const range = document.createRange();
      const selection = window.getSelection();
      range.selectNodeContents(contentEditableDiv);
      range.collapse(false);
      selection.removeAllRanges();
      selection.addRange(range);
    };

    window.addEventListener("bonfire:focus-composer", this.focusComposerHandler);

    createEditor(this, hidden_input, composer$)
      .then(({ editor, cleanup }) => {
        this.editor = editor;
        this.cleanup = cleanup;
      })
      .catch(error => {
        console.error("Failed to create editor:", error);
      });
  },

  destroyed() {
    if (this.cleanup) {
      this.cleanup();
    }
    
    window.removeEventListener(
      "bonfire:focus-composer",
      this.focusComposerHandler,
    );
  },
};
